<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <title>RPM Reports</title>
    <style>
        :root {
            --border:#ddd;
            --muted:#666;
            --bg:#fafafa;
            --card:#fff;
            --danger:#b00020;
        }
        body {
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
            margin: 0;
            background: var(--bg);
            color: #111;
        }
        header {
            background: #fff;
            border-bottom: 1px solid var(--border);
            padding: 14px 16px;
            display: flex;
            align-items: baseline;
            gap: 12px;
            flex-wrap: wrap;
        }
        header h2 { margin: 0; font-size: 18px; }
        header .muted { color: var(--muted); }
        .wrap {
            max-width: 1240px;
            margin: 0 auto;
            padding: 16px;
            display: grid;
            grid-template-columns: 340px 1fr;
            gap: 14px;
        }
        @media (max-width: 980px) {
            .wrap { grid-template-columns: 1fr; }
        }
        .panel, .report {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px;
        }
        .panel h3, .report h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
        }
        .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
        button, select, input {
            padding: 8px 10px;
            border: 1px solid var(--border);
            border-radius: 10px;
            background: #fff;
            font: inherit;
        }
        button { cursor: pointer; }
        button.primary { background: #111; color: #fff; border-color: #111; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .muted { color: var(--muted); font-size: 12px; }
        .err { color: var(--danger); white-space: pre-wrap; font-size: 12px; margin-top: 10px; }
        .box {
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 10px;
            background: #fff;
        }
        .list {
            max-height: 220px;
            overflow: auto;
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 8px;
            background: #fff;
        }
        .list label {
            display: flex;
            gap: 8px;
            align-items: center;
            padding: 4px 2px;
            font-size: 13px;
        }
        .list input[type="checkbox"] { transform: translateY(1px); }
        .pill {
            display:inline-flex;
            align-items:center;
            gap:6px;
            padding: 3px 8px;
            border: 1px solid var(--border);
            border-radius: 999px;
            font-size: 12px;
            background: #fff;
        }

        .patient-section {
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px;
            margin-top: 12px;
            background: #fff;
        }
        .patient-head {
            display:flex;
            justify-content: space-between;
            align-items: baseline;
            gap: 10px;
            flex-wrap: wrap;
        }
        .patient-head h4 { margin: 0; font-size: 14px; }
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 12px;
            margin-top: 10px;
        }
        canvas {
            width: 100%;
            height: 200px;
            border: 1px solid var(--border);
            border-radius: 12px;
            background: #fff;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }
        th, td {
            text-align: left;
            padding: 6px 6px;
            border-bottom: 1px solid #eee;
            vertical-align: top;
        }
        th { color: var(--muted); font-weight: 600; }
        .small { font-size: 12px; }
        .sep { height: 1px; background: #eee; margin: 10px 0; }
    </style>
</head>
<body>
<header>
    <h2>RPM Report Generator</h2>
    <div class="muted" id="status">Not loaded.</div>
    <div class="muted" id="rangeHint"></div>
</header>

<div class="wrap">
    <aside class="panel">
        <h3>Report inputs</h3>

        <div class="row" style="margin-bottom:10px;">
            <button id="loadBtn">Load latest telemetry</button>
            <button id="printBtn">Print</button>
        </div>

        <div class="box">
            <div class="row" style="justify-content: space-between;">
                <div class="muted">Patients</div>
                <div class="row">
                    <button id="allBtn" class="small">All</button>
                    <button id="noneBtn" class="small">None</button>
                </div>
            </div>
            <div style="margin-top:8px;">
                <input id="patientFilter" type="text" placeholder="Filter (e.g., 01, Bed 03)" style="width:100%; box-sizing:border-box;">
            </div>
            <div class="list" id="patientsList" style="margin-top:8px;"></div>
            <div class="muted" style="margin-top:6px;" id="patientsHint"></div>
        </div>

        <div class="sep"></div>

        <div class="box">
            <div class="muted">Time window (from telemetry timestamps)</div>
            <div class="row" style="margin-top:8px;">
                <select id="preset">
                    <option value="5">Last 5 minutes</option>
                    <option value="10" selected>Last 10 minutes</option>
                    <option value="30">Last 30 minutes</option>
                    <option value="60">Last 60 minutes</option>
                    <option value="custom">Custom</option>
                </select>
                <button id="applyPresetBtn">Apply</button>
            </div>
            <div class="row" style="margin-top:8px;">
                <div style="flex:1; min-width: 140px;">
                    <div class="muted small">Start</div>
                    <input id="startInput" type="datetime-local" style="width:100%; box-sizing:border-box;">
                </div>
                <div style="flex:1; min-width: 140px;">
                    <div class="muted small">End</div>
                    <input id="endInput" type="datetime-local" style="width:100%; box-sizing:border-box;">
                </div>
            </div>
            <div class="muted" style="margin-top:6px;">
                Note: the backend returns the most recent samples per bed, so very old windows may not exist.
            </div>
        </div>

        <div class="sep"></div>

        <div class="box">
            <div class="muted">Vitals to include</div>
            <div class="list" style="max-height: 180px; margin-top:8px;">
                <label><input type="checkbox" class="vital" value="hr" checked> Heart rate (bpm)</label>
                <label><input type="checkbox" class="vital" value="rr" checked> Resp. rate (breaths/min)</label>
                <label><input type="checkbox" class="vital" value="sys" checked> BP systolic (mmHg)</label>
                <label><input type="checkbox" class="vital" value="dia" checked> BP diastolic (mmHg)</label>
                <label><input type="checkbox" class="vital" value="temp" checked> Temperature (°C)</label>
                <label><input type="checkbox" class="vital" value="ecg"> ECG (latest segment only)</label>
            </div>
            <div class="muted" style="margin-top:6px;">
                “Alert episodes” are derived from these vitals using the same default adult threshold bands.
            </div>
        </div>

        <div class="sep"></div>

        <div class="row">
            <button id="generateBtn" class="primary" disabled>Generate report</button>
            <button id="csvBtn" disabled>Download CSV</button>
        </div>

        <div id="error" class="err"></div>
    </aside>

    <main class="report">
        <h3>Report output</h3>
        <div class="muted" id="summaryHint">Load telemetry, choose inputs, then generate.</div>
        <div id="reportOut"></div>
    </main>
</div>

<script>

    const TELEMETRY_URL = new URL("telemetry", window.location.href).toString();


    const THRESHOLDS = {
        hr:   { lowAmber: 50,   lowRed: 40,   highAmber: 110, highRed: 130, unit: "bpm", name: "Heart rate" },
        rr:   { lowAmber: 10,   lowRed: 8,    highAmber: 24,  highRed: 30,  unit: "breaths/min", name: "Resp. rate" },
        temp: { lowAmber: 36.0, lowRed: 35.0, highAmber: 38.0, highRed: 39.0, unit: "°C", name: "Temperature" },
        sys:  { lowAmber: 80,   lowRed: 70,   highAmber: 160, highRed: 180, unit: "mmHg", name: "BP systolic" },
        dia:  { lowAmber: 50,   lowRed: 40,   highAmber: 100, highRed: 110, unit: "mmHg", name: "BP diastolic" }
    };

    const statusEl = document.getElementById("status");
    const rangeHintEl = document.getElementById("rangeHint");
    const errEl = document.getElementById("error");
    const patientsListEl = document.getElementById("patientsList");
    const patientsHintEl = document.getElementById("patientsHint");
    const patientFilterEl = document.getElementById("patientFilter");
    const generateBtn = document.getElementById("generateBtn");
    const csvBtn = document.getElementById("csvBtn");
    const reportOut = document.getElementById("reportOut");
    const summaryHint = document.getElementById("summaryHint");
    const presetSel = document.getElementById("preset");
    const applyPresetBtn = document.getElementById("applyPresetBtn");
    const startInput = document.getElementById("startInput");
    const endInput = document.getElementById("endInput");

    let lastPatients = null; // map bedId -> telemetry object
    let lastFetchAtMs = 0;

    function asPatientsMap(payload) {
        if (!payload) return {};
        return payload.patients || payload;
    }

    function bedIds(patients) {
        return Object.keys(patients || {}).sort((a,b) => a.localeCompare(b));
    }

    function toIsoLocal(ms) {
        const d = new Date(ms);
        const pad = n => String(n).padStart(2, "0");
        const y = d.getFullYear();
        const m = pad(d.getMonth() + 1);
        const da = pad(d.getDate());
        const hh = pad(d.getHours());
        const mm = pad(d.getMinutes());
        return `${y}-${m}-${da}T${hh}:${mm}`;
    }

    function fmtTime(ms) {
        if (!Number.isFinite(ms)) return "-";
        return new Date(ms).toLocaleString();
    }

    function safeNum(x) {
        return (typeof x === "number" && Number.isFinite(x)) ? x : null;
    }

    function seriesRange(p) {
        const ts = Array.isArray(p?.ts) ? p.ts : [];
        if (!ts.length) return null;
        let min = Infinity, max = -Infinity;
        for (const t of ts) {
            if (typeof t !== "number") continue;
            if (t < min) min = t;
            if (t > max) max = t;
        }
        if (!Number.isFinite(min) || !Number.isFinite(max)) return null;
        return { min, max };
    }

    function globalRange(patients, selectedBeds) {
        let min = Infinity, max = -Infinity, any = false;
        for (const bed of selectedBeds) {
            const r = seriesRange(patients[bed]);
            if (!r) continue;
            any = true;
            if (r.min < min) min = r.min;
            if (r.max > max) max = r.max;
        }
        if (!any) return null;
        return { min, max };
    }

    function selectedBeds() {
        const boxes = patientsListEl.querySelectorAll('input[type="checkbox"][data-bed]');
        const out = [];
        boxes.forEach(b => { if (b.checked) out.push(b.getAttribute("data-bed")); });
        return out;
    }

    function selectedVitals() {
        const boxes = document.querySelectorAll('input.vital[type="checkbox"]');
        const out = [];
        boxes.forEach(b => { if (b.checked) out.push(b.value); });
        return out;
    }

    function setAllPatients(checked) {
        const boxes = patientsListEl.querySelectorAll('input[type="checkbox"][data-bed]');
        boxes.forEach(b => b.checked = checked);
        updateGenerateEnabled();
    }

    function updateGenerateEnabled() {
        const ok = !!lastPatients && selectedBeds().length > 0 && selectedVitals().length > 0;
        generateBtn.disabled = !ok;
        csvBtn.disabled = !ok;
    }

    function buildPatientsList(patients) {
        patientsListEl.innerHTML = "";
        const beds = bedIds(patients);
        for (const bed of beds) {
            const id = `bed_${bed.replace(/\s+/g, "_")}`;
            const label = document.createElement("label");
            const cb = document.createElement("input");
            cb.type = "checkbox";
            cb.id = id;
            cb.checked = true;
            cb.setAttribute("data-bed", bed);
            cb.addEventListener("change", updateGenerateEnabled);

            const span = document.createElement("span");
            span.textContent = bed;

            label.appendChild(cb);
            label.appendChild(span);
            patientsListEl.appendChild(label);
        }
        patientsHintEl.textContent = beds.length ? `${beds.length} patient(s) available.` : `No patients returned from ${TELEMETRY_URL}.`;
        updateGenerateEnabled();
    }

    function applyFilter() {
        const q = (patientFilterEl.value || "").trim().toLowerCase();
        const labels = patientsListEl.querySelectorAll("label");
        labels.forEach(l => {
            const bed = l.textContent.toLowerCase();
            l.style.display = (!q || bed.includes(q)) ? "" : "none";
        });
    }

    function parseMsFromInput(el) {
        const v = el.value;
        if (!v) return null;
        const t = new Date(v).getTime();
        return Number.isFinite(t) ? t : null;
    }

    function applyPreset(minutesOrCustom) {
        if (!lastPatients) return;
        const beds = selectedBeds();
        if (!beds.length) return;

        const r = globalRange(lastPatients, beds);
        if (!r) return;

        if (minutesOrCustom === "custom") {
            return;
        }
        const mins = Number(minutesOrCustom);
        const end = r.max;
        const start = Math.max(r.min, end - mins * 60 * 1000);
        startInput.value = toIsoLocal(start);
        endInput.value = toIsoLocal(end);
    }

    function extractWindow(p, startMs, endMs, vitalKey) {
        const ts = Array.isArray(p?.ts) ? p.ts : [];
        const vals = Array.isArray(p?.[vitalKey]) ? p[vitalKey] : [];
        const n = Math.min(ts.length, vals.length);
        const out = [];
        for (let i = 0; i < n; i++) {
            const t = ts[i];
            if (typeof t !== "number") continue;
            if (t < startMs || t > endMs) continue;
            const v = safeNum(vals[i]);
            out.push({ t, v });
        }
        return out;
    }

    function classify(v, band) {
        if (v === null || band == null) return 0;
        if (v <= band.lowRed || v >= band.highRed) return 2;  // RED
        if (v <= band.lowAmber || v >= band.highAmber) return 1; // AMBER
        return 0;
    }

    function computeEpisodes(points, band) {

        const eps = [];
        let active = null; // {level,startMs}
        for (let i = 0; i < points.length; i++) {
            const lvl = classify(points[i].v, band);
            const t = points[i].t;
            if (lvl > 0) {
                if (!active) {
                    active = { level: lvl, startMs: t };
                } else {

                    if (active.level !== lvl) {
                        eps.push({ level: active.level, startMs: active.startMs, endMs: t });
                        active = { level: lvl, startMs: t };
                    }
                }
            } else {
                if (active) {
                    eps.push({ level: active.level, startMs: active.startMs, endMs: t });
                    active = null;
                }
            }
        }
        if (active && points.length) {
            eps.push({ level: active.level, startMs: active.startMs, endMs: points[points.length - 1].t });
        }

        const merged = [];
        for (const e of eps) {
            const last = merged[merged.length - 1];
            if (last && last.level === e.level && last.endMs === e.startMs) {
                last.endMs = e.endMs;
            } else {
                merged.push({ ...e });
            }
        }
        return merged;
    }

    function stats(points) {
        let n = 0, sum = 0, min = Infinity, max = -Infinity;
        for (const p of points) {
            if (p.v === null) continue;
            n++;
            sum += p.v;
            if (p.v < min) min = p.v;
            if (p.v > max) max = p.v;
        }
        if (n === 0) return null;
        return { n, mean: sum / n, min, max };
    }

    function nice(n, digits=1) {
        if (!Number.isFinite(n)) return "--";
        return n.toFixed(digits);
    }

    function drawChart(canvas, points, band, title, unit) {
        const ctx = canvas.getContext("2d");
        const W = canvas.width, H = canvas.height;

        ctx.clearRect(0, 0, W, H);

        ctx.fillStyle = "#fff";
        ctx.fillRect(0, 0, W, H);

        const padL = 46, padR = 12, padT = 26, padB = 30;
        const plotW = W - padL - padR;
        const plotH = H - padT - padB;

        ctx.fillStyle = "#111";
        ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.fillText(`${title} (${unit})`, padL, 16);

        if (!points.length) {
            ctx.fillStyle = "#666";
            ctx.fillText("No data in selected window.", padL, padT + 20);
            return;
        }

        let minT = Infinity, maxT = -Infinity;
        let minV = Infinity, maxV = -Infinity;
        for (const p of points) {
            if (typeof p.t === "number") {
                if (p.t < minT) minT = p.t;
                if (p.t > maxT) maxT = p.t;
            }
            if (p.v !== null) {
                if (p.v < minV) minV = p.v;
                if (p.v > maxV) maxV = p.v;
            }
        }

        if (band) {
            minV = Math.min(minV, band.lowRed, band.lowAmber);
            maxV = Math.max(maxV, band.highRed, band.highAmber);
        }
        if (!Number.isFinite(minV) || !Number.isFinite(maxV) || minV === maxV) {
            minV -= 1; maxV += 1;
        }
        const dv = (maxV - minV);
        minV -= dv * 0.05;
        maxV += dv * 0.05;

        function xOf(t) {
            if (maxT === minT) return padL;
            return padL + ((t - minT) / (maxT - minT)) * plotW;
        }
        function yOf(v) {
            return padT + (1 - ((v - minV) / (maxV - minV))) * plotH;
        }

        ctx.strokeStyle = "#ccc";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padL, padT);
        ctx.lineTo(padL, padT + plotH);
        ctx.lineTo(padL + plotW, padT + plotH);
        ctx.stroke();

        ctx.fillStyle = "#666";
        ctx.font = "11px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.fillText(fmtTime(minT), padL, H - 10);
        const endLabel = fmtTime(maxT);
        const endW = ctx.measureText(endLabel).width;
        ctx.fillText(endLabel, padL + plotW - endW, H - 10);

        ctx.fillText(nice(maxV, 1), 8, padT + 10);
        ctx.fillText(nice(minV, 1), 8, padT + plotH);

        function hLine(val, label) {
            const y = yOf(val);
            ctx.strokeStyle = "#bbb";
            ctx.setLineDash([5, 4]);
            ctx.beginPath();
            ctx.moveTo(padL, y);
            ctx.lineTo(padL + plotW, y);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = "#666";
            ctx.fillText(label, padL + 6, y - 3);
        }

        if (band) {
            hLine(band.lowAmber, "low amber");
            hLine(band.lowRed, "low red");
            hLine(band.highAmber, "high amber");
            hLine(band.highRed, "high red");
        }

        // line
        ctx.strokeStyle = "#111";
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        let started = false;
        for (const p of points) {
            if (p.v === null) continue;
            const x = xOf(p.t);
            const y = yOf(p.v);
            if (!started) { ctx.moveTo(x, y); started = true; }
            else ctx.lineTo(x, y);
        }
        ctx.stroke();

        ctx.fillStyle = "#111";
        for (const p of points) {
            if (p.v === null) continue;
            const x = xOf(p.t);
            const y = yOf(p.v);
            ctx.fillRect(x - 1, y - 1, 2, 2);
        }
    }

    function renderEpisodesTable(episodes) {
        if (!episodes.length) {
            const div = document.createElement("div");
            div.className = "muted";
            div.textContent = "No alert episodes detected in this window.";
            return div;
        }
        const table = document.createElement("table");
        const thead = document.createElement("thead");
        thead.innerHTML = `<tr><th>Level</th><th>Start</th><th>End</th><th>Duration</th></tr>`;
        table.appendChild(thead);
        const tb = document.createElement("tbody");
        for (const e of episodes) {
            const lvl = e.level === 2 ? "RED" : "AMBER";
            const durMs = Math.max(0, e.endMs - e.startMs);
            const durS = Math.round(durMs / 1000);
            const tr = document.createElement("tr");
            tr.innerHTML = `
        <td>${lvl}</td>
        <td>${fmtTime(e.startMs)}</td>
        <td>${fmtTime(e.endMs)}</td>
        <td>${durS}s</td>
      `;
            tb.appendChild(tr);
        }
        table.appendChild(tb);
        return table;
    }

    function renderPatientSection(bed, p, startMs, endMs, vitals) {
        const section = document.createElement("div");
        section.className = "patient-section";

        const head = document.createElement("div");
        head.className = "patient-head";

        const title = document.createElement("h4");
        title.textContent = bed;

        const pills = document.createElement("div");
        pills.className = "row";
        pills.style.gap = "8px";

        const r = seriesRange(p);
        const avail = r ? `${fmtTime(r.min)} → ${fmtTime(r.max)}` : "No timestamps";
        const pill1 = document.createElement("span");
        pill1.className = "pill";
        pill1.textContent = `Available: ${avail}`;
        pills.appendChild(pill1);

        const pill2 = document.createElement("span");
        pill2.className = "pill";
        pill2.textContent = `Window: ${fmtTime(startMs)} → ${fmtTime(endMs)}`;
        pills.appendChild(pill2);

        head.appendChild(title);
        head.appendChild(pills);
        section.appendChild(head);

        const sumTable = document.createElement("table");
        sumTable.style.marginTop = "10px";
        sumTable.innerHTML = `<thead><tr>
      <th>Vital</th><th>n</th><th>Mean</th><th>Min</th><th>Max</th>
    </tr></thead>`;
        const tb = document.createElement("tbody");

        const grid = document.createElement("div");
        grid.className = "grid";

        const overallPoints = [];

        const episodesByVital = {};

        const ts = Array.isArray(p?.ts) ? p.ts : [];
        for (let i = 0; i < ts.length; i++) {
            const t = ts[i];
            if (typeof t !== "number") continue;
            if (t < startMs || t > endMs) continue;

            let worst = 0; // 0 green, 1 amber, 2 red
            for (const vk of vitals) {
                if (vk === "ecg") continue;
                const band = THRESHOLDS[vk];
                const arr = Array.isArray(p?.[vk]) ? p[vk] : [];
                const v = safeNum(arr[i]);
                const lvl = classify(v, band);
                if (lvl > worst) worst = lvl;
            }
            overallPoints.push({ t, v: worst });
        }

        for (const vk of vitals) {
            if (vk === "ecg") continue;
            const band = THRESHOLDS[vk];
            const pts = extractWindow(p, startMs, endMs, vk);

            const st = stats(pts);
            const tr = document.createElement("tr");
            if (!st) {
                tr.innerHTML = `<td>${band?.name || vk}</td><td>0</td><td>--</td><td>--</td><td>--</td>`;
            } else {
                tr.innerHTML = `<td>${band.name}</td><td>${st.n}</td><td>${nice(st.mean, 1)}</td><td>${nice(st.min, 1)}</td><td>${nice(st.max, 1)}</td>`;
            }
            tb.appendChild(tr);

            const card = document.createElement("div");
            card.className = "box";
            const canv = document.createElement("canvas");
            canv.width = 900;
            canv.height = 260;
            card.appendChild(canv);

            const eps = computeEpisodes(pts, band);
            episodesByVital[vk] = eps;

            drawChart(canv, pts, band, band.name, band.unit);

            const below = document.createElement("div");
            below.style.marginTop = "10px";
            const label = document.createElement("div");
            label.className = "muted";
            label.textContent = "Derived alert episodes (based on thresholds)";
            below.appendChild(label);
            below.appendChild(renderEpisodesTable(eps));

            card.appendChild(below);
            grid.appendChild(card);
        }

        sumTable.appendChild(tb);
        section.appendChild(sumTable);

        if (vitals.some(v => v !== "ecg")) {
            const overallBand = null; // not used
            const overallEpisodes = [];
            // compute episodes on "level series"
            let active = null;
            for (const p2 of overallPoints) {
                const lvl = p2.v;
                const t = p2.t;
                if (lvl > 0) {
                    if (!active) active = { level: lvl, startMs: t };
                    else if (active.level !== lvl) {
                        overallEpisodes.push({ level: active.level, startMs: active.startMs, endMs: t });
                        active = { level: lvl, startMs: t };
                    }
                } else {
                    if (active) {
                        overallEpisodes.push({ level: active.level, startMs: active.startMs, endMs: t });
                        active = null;
                    }
                }
            }
            if (active && overallPoints.length) {
                overallEpisodes.push({ level: active.level, startMs: active.startMs, endMs: overallPoints[overallPoints.length - 1].t });
            }

            const overallBox = document.createElement("div");
            overallBox.className = "box";
            overallBox.style.marginTop = "12px";
            const label = document.createElement("div");
            label.className = "muted";
            label.textContent = "Overall alert episodes (worst across selected vitals)";
            overallBox.appendChild(label);
            overallBox.appendChild(renderEpisodesTable(overallEpisodes));
            section.appendChild(overallBox);
        }

        if (vitals.includes("ecg")) {
            const ecgArr = Array.isArray(p?.ecg) ? p.ecg : [];
            const fs = typeof p?.ecgFs === "number" ? p.ecgFs : null;
            const start = typeof p?.ecgTsStart === "number" ? p.ecgTsStart : null;

            const ecgBox = document.createElement("div");
            ecgBox.className = "box";
            ecgBox.style.marginTop = "12px";

            const hdr = document.createElement("div");
            hdr.className = "row";
            hdr.style.justifyContent = "space-between";

            const label = document.createElement("div");
            label.innerHTML = `<div><strong>ECG (latest uploaded segment)</strong></div>
        <div class="muted small">${start ? ("Start: " + fmtTime(start)) : ""} ${fs ? (" • fs=" + fs + "Hz") : ""} ${ecgArr.length ? (" • n=" + ecgArr.length) : ""}</div>`;
            hdr.appendChild(label);
            ecgBox.appendChild(hdr);

            const canv = document.createElement("canvas");
            canv.width = 900;
            canv.height = 240;
            ecgBox.appendChild(canv);

            // simple ECG plot
            const ctx = canv.getContext("2d");
            ctx.clearRect(0,0,canv.width,canv.height);
            ctx.fillStyle = "#fff"; ctx.fillRect(0,0,canv.width,canv.height);

            if (!ecgArr.length) {
                ctx.fillStyle = "#666";
                ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
                ctx.fillText("No ECG samples available for this patient.", 16, 28);
            } else {
                let min = Infinity, max = -Infinity;
                for (const v of ecgArr) {
                    if (typeof v !== "number") continue;
                    if (v < min) min = v;
                    if (v > max) max = v;
                }
                if (!Number.isFinite(min) || !Number.isFinite(max) || min === max) { min -= 1; max += 1; }
                const W = canv.width, H = canv.height;
                const pad = 12;
                ctx.strokeStyle = "#111";
                ctx.lineWidth = 1.2;
                ctx.beginPath();
                for (let i = 0; i < ecgArr.length; i++) {
                    const x = pad + (i / (ecgArr.length - 1)) * (W - pad*2);
                    const y = (H - pad) - ((ecgArr[i] - min) / (max - min)) * (H - pad*2);
                    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            section.appendChild(ecgBox);
        }

        section.appendChild(grid);
        return section;
    }

    function buildCsv(patients, beds, startMs, endMs) {
        const cols = ["bed", "timestamp_ms", "timestamp_iso", "hr", "rr", "sys", "dia", "temp"];
        let out = cols.join(",") + "\n";

        for (const bed of beds) {
            const p = patients[bed];
            const ts = Array.isArray(p?.ts) ? p.ts : [];
            const hr = Array.isArray(p?.hr) ? p.hr : [];
            const rr = Array.isArray(p?.rr) ? p.rr : [];
            const sys = Array.isArray(p?.sys) ? p.sys : [];
            const dia = Array.isArray(p?.dia) ? p.dia : [];
            const temp = Array.isArray(p?.temp) ? p.temp : [];
            const n = Math.max(ts.length, hr.length, rr.length, sys.length, dia.length, temp.length);
            for (let i = 0; i < n; i++) {
                const t = ts[i];
                if (typeof t !== "number") continue;
                if (t < startMs || t > endMs) continue;
                const row = [
                    bed,
                    t,
                    new Date(t).toISOString(),
                    safeNum(hr[i]),
                    safeNum(rr[i]),
                    safeNum(sys[i]),
                    safeNum(dia[i]),
                    safeNum(temp[i])
                ].map(x => (x === null || x === undefined) ? "" : String(x));
                out += row.join(",") + "\n";
            }
        }
        return out;
    }

    async function loadTelemetry() {
        errEl.textContent = "";
        statusEl.textContent = "Loading telemetry…";
        rangeHintEl.textContent = "";
        reportOut.innerHTML = "";
        summaryHint.textContent = "Loading…";

        const t0 = performance.now();
        const res = await fetch(TELEMETRY_URL, { cache: "no-store" });
        if (!res.ok) throw new Error(`GET ${TELEMETRY_URL} failed: ${res.status} ${res.statusText}`);
        const data = await res.json();
        const dt = Math.round(performance.now() - t0);

        lastFetchAtMs = Date.now();
        lastPatients = asPatientsMap(data);

        const beds = bedIds(lastPatients);
        statusEl.textContent = `Loaded ${beds.length} patient(s) • ${dt} ms • ${TELEMETRY_URL}`;

        buildPatientsList(lastPatients);
        applyFilter();

        const selBeds = selectedBeds();
        if (selBeds.length) {
            const r = globalRange(lastPatients, selBeds);
            if (r) {
                rangeHintEl.textContent = `Telemetry range (selected): ${fmtTime(r.min)} → ${fmtTime(r.max)}`;
                applyPreset(presetSel.value);
            }
        }

        summaryHint.textContent = "Choose inputs, then click “Generate report”.";
        updateGenerateEnabled();
    }

    function generateReport() {
        errEl.textContent = "";
        reportOut.innerHTML = "";

        if (!lastPatients) {
            errEl.textContent = "No telemetry loaded yet.";
            return;
        }

        const beds = selectedBeds();
        const vitals = selectedVitals();
        if (!beds.length) {
            errEl.textContent = "Select at least one patient.";
            return;
        }
        if (!vitals.length) {
            errEl.textContent = "Select at least one vital.";
            return;
        }

        let startMs = parseMsFromInput(startInput);
        let endMs = parseMsFromInput(endInput);

        if (!Number.isFinite(startMs) || !Number.isFinite(endMs) || startMs >= endMs) {
            const r = globalRange(lastPatients, beds);
            if (!r) {
                errEl.textContent = "No timestamps found for selected patients.";
                return;
            }
            const mins = Number(presetSel.value === "custom" ? 10 : presetSel.value);
            endMs = r.max;
            startMs = Math.max(r.min, endMs - mins * 60 * 1000);
            startInput.value = toIsoLocal(startMs);
            endInput.value = toIsoLocal(endMs);
        }

        const top = document.createElement("div");
        top.className = "box";
        top.innerHTML = `
      <div class="row" style="justify-content: space-between;">
        <div>
          <div><strong>Report</strong></div>
          <div class="muted small">Generated: ${new Date().toLocaleString()}</div>
        </div>
        <div class="row">
          <span class="pill">Patients: ${beds.length}</span>
          <span class="pill">Vitals: ${vitals.join(", ")}</span>
        </div>
      </div>
      <div class="muted" style="margin-top:8px;">Window: ${fmtTime(startMs)} → ${fmtTime(endMs)}</div>
    `;
        reportOut.appendChild(top);

        for (const bed of beds) {
            const p = lastPatients[bed];
            if (!p) continue;
            reportOut.appendChild(renderPatientSection(bed, p, startMs, endMs, vitals));
        }

        summaryHint.textContent = "";
    }

    // UI wiring
    document.getElementById("loadBtn").addEventListener("click", () =>
        loadTelemetry().catch(e => errEl.textContent = e.stack || e)
    );
    document.getElementById("printBtn").addEventListener("click", () => window.print());
    document.getElementById("allBtn").addEventListener("click", () => setAllPatients(true));
    document.getElementById("noneBtn").addEventListener("click", () => setAllPatients(false));
    patientFilterEl.addEventListener("input", applyFilter);

    document.querySelectorAll('input.vital[type="checkbox"]').forEach(cb =>
        cb.addEventListener("change", updateGenerateEnabled)
    );

    applyPresetBtn.addEventListener("click", () => {
        applyPreset(presetSel.value);
    });

    presetSel.addEventListener("change", () => {
        if (presetSel.value !== "custom") applyPreset(presetSel.value);
    });

    generateBtn.addEventListener("click", generateReport);

    csvBtn.addEventListener("click", () => {
        if (!lastPatients) return;
        const beds = selectedBeds();
        const startMs = parseMsFromInput(startInput);
        const endMs = parseMsFromInput(endInput);
        if (!Number.isFinite(startMs) || !Number.isFinite(endMs) || startMs >= endMs) {
            errEl.textContent = "Set a valid time window before downloading CSV.";
            return;
        }
        const csv = buildCsv(lastPatients, beds, startMs, endMs);
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `rpm_report_${new Date().toISOString().replace(/[:.]/g, "-")}.csv`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
    });

    loadTelemetry().catch(e => errEl.textContent = e.stack || e);
</script>
</body>
</html>
